# 2week2hours - Gamers

целевая технология - ORM библиотека Doctrine

## Чему научимся:
Создание протопипа современного веб-сайта, с упором на управление моделями (см. M в MVC).
Проект называетcя "Gamers", и представляет собой базу игр, c некоторой бизнес-логикой вокруг этой базы.
В процессе мы разберём возможности Doctrine, оценим скорость разработки,
гибкость (или негибкость) решений из коробки, а также производительность библиотеки.

## init
Обычно я начинаю проект с Docker окружения. Соберём 3 сервиса:

	- php - бэкенд на PHP, всё стандартно.
	- nginx - это же веб, нужен веб сервер.
	- workspace - это специальный образ, заботливо собраный мной для "консольной" части моих проектов.
	Сюда входят пакетные менеджеры для PHP и Java Script, инструменты проверки качества кода,
	кроны, профайлер и ещё много чего полезного. В данном проекте, вероятно, понадобятся только пакетные менеджеры.

[docker-compose & Makefile]

Небольшое отступление по поводу фреймворков. Условно говоря, в 90% случаев фреймворк нужен, и ещё в 5% - вероятно, самописный.
Не стоит тешить себя мыслями, что вы крутой разраб, у которого всё всегда под контролем. Если проект коммерческий и/или над
ним работает >2 человек - нарастающая сложность наверняка похоронит под собой все благие намерения минимализма. В данном случае
я осознано пишу велосипед, так как моя цель - сосредоточиться на конкретной теме, не отвлекаясь на специфичные
особенности готовых к использованию фреймворков.

Что по зависимостям? Нам понадобятся сама Doctrine и инструмент для генерации тестовых данных.
Также при работе с БД стандартной практикой является механизм миграций, не будем ходить далеко и возьмём doctrine/migrations.
Конфигурация в yml требует дополнительной библиотеки, её тоже нужно указать в зависимостях.
Так как нам волей-неволей придётся писать контроллеры, лично я категорически рекомендую использовать ООП обёртку над HTTP. Получается так:
[composer.json]

Касательно фронта - для меня, в-основном-бэкендера немного умеющего в vue, самый простой путь это установить
vue/vue-bootstrap/vue-router/laravel-mix (?!wtf, что это вообще такое?) через npm.
[package.json]

Кстати, базу данных я не устанавливаю - SQLite вполне достаточно для примера, а Doctrine уже сейчас оказывает нам услугу -
благодаря DBAL в дальнейшем мы сможем легко и непринужденно перелезть на любую другую БД (если потребуется)

[тут полная последовательность действий для развертки]

## Проектирование данных

Тут начинается интересное. Очевидно, ключевой сущностью будет Game, также сайтом будут пользоваться геймеры, поэтому будет и Profile.
Игры кто-то создаёт, поэтому также напрашиваются сущности Company и People (последнее выглядит очень абстрактно, зато в дальнейшем
к People можно привязать кого угодно - и разработчика, и директора, и геймера, при том что всё это может быть один и тот же человек).
Итого 4 сущности, но если подумать о том, как они связаны между собой, появляются данные, которые обретают смысл только в контексте
связи A с B. Например, связь Game-Profile даёт сущность Favorite (мы же хотим выбирать любимые игры?), а People-Company даёт нам
Position - это может быть как должность в компании, так и отношение вида 'fan' или 'hater' =)

Данные в базе достаточно четко делятся на 2 подгруппы: динамические и заранее определённые, т.е. словари.
Словари имеют относительно небольшое число записей и на них можно завязывать бизнес логику.
Например, жанр игры - отличный пример словаря, а вот имя пользователя - нет. Всё, что было выше, относится к динамическим, не считая
Position. Придумаем ещё несколько словарей - Genre, Engine и Platform выглядят подходяще.

Опишем связи и поля данных:

id, created_at, updated_at - будет у всех основных сущностей. Я так хочу и всё тут =)
Касательно id - я заранее завязываюсь на базу без шардирования, поэтому id обычный, инкрементальный.
(В обратном случае стоит использовать UUID)

`Game`

	genre_game_id     к каким жанрам относится
	platform_game_id  на каких платформах доступна
	company_game_id   Компании (разработчик, издатель и пр.)
	author_game_id    Кто делал игру
	name          Название
	description   Описание
	logo          Логотип
	release_date  Дата выпуска
	engine_id     Игровой движок
	multiplayer   Есть ли режим совместной игры

`Profile`

	nickname    никнейм
	password    пароль
	email       почта
	favorite_id любимые игры
	people_id

`Company`

	name    Имя компании
	founded Дата основания

`People`

	name        fio или аналогичная информация
	position_id позиция в компании

## Скелет проекта

Напишем основу проекта на PHP. Создадим 3 директории - config для конфигураций, src
для собственно кода и public для точки входа и ассетов. Помимо этого, в корне
будет 2 php скрипта - cli.php, для кастомных консольных команд
и cli-config.php - точка входа для консольных команд доктрины (нууу, так уж она называется `¯\_(ツ)_/¯`)

## Маппинг

ORM начинается с маппинга. т.к. мы уже спроектировали данные, нам достаточно
описать их в виде yaml и просто сгенерировать код сущностей + схему в базе
следующими командами:
[]

Если бы БД уже существовала, процесс был бы не намного сложнее. Мы также
могли описать маппинг (или даже сгенерировать его, используя schemaManager)
а затем сделать тоже самое, предварительно проверив правильность маппинга
через команду diff:
[]

Как вы уже могли заметить, я хотел бы "отнаследовать" некоторые поля, чтобы не описывать их каждый раз - это created_at и updated_at.
Можно ли это сделать с помощью доктрины? Тут ситуация двоякая. Если мы используем аннотации - можно выделить эти поля в трейт,
но при этом получается что нам нужно использовать аннотации и в ручную писать Entity. Если мы используем yaml маппинг -
общие поля нужно писать в каждом маппинге, зато в сущностях они будут сгенерены автоматически. Это проще и это ещё один + в сторону выбора yaml.

Пример для Game:

	Entity\Game:
	  type: entity
	  table: game
	  id:
	    id:
	      type: integer
	      generator:
	        strategy: AUTO
	  fields:
	    created_at:
	      type: datetime
	    updated_at:
	      type: datetime
	    name:
	      type: string
	    description:
	      type: string
	    logo:
	      type: string
	    release_date:
	      type: date
	    multiplayer:
	      type: boolean

...
Итак, сущности у нас есть. Теперь определим репозиторий для организации выборок этих сущностей.
...
Теперь заполним таблицы тестовыми данными и сделаем апи для получения этих данных на фронтенде.
(пока только на чтение). Для этого напишем простенький скрипт, запускающий специальные "консольные" классы,
которые мы сможем определить в дальнейшем.
Чем хорош Faker - так это тем что он может генерировать практически ВСЁ, но в данном случае - ещё и сущности)
Угадайте, сколько кода нужно, чтобы создать 100 игр в нашей базе? Вот:

	$faker = Factory::create('ru_RU');
    $populator = new Populator($faker, $em);
    $populator->addEntity(':Game', 100, [
        'name' => function() use ($faker) { return ucfirst($faker->word) .' '. ucfirst($faker->word); },
        'logo' => function() use ($faker) { return $faker->imageUrl(); },
        'created_at' => function() use ($faker) { return $faker->dateTimeBetween('-5 year', '-1 year'); },
        'updated_at' => function() use ($faker) { return $faker->dateTimeBetween('-11 month', 'now'); },
    ]);
    $populator->execute();

Осталось немного допилить алгоритм, чтобы данные не просто добавлялись, но и были связаны между собой.

...
Отлично!
